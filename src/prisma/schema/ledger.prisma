// In theory the type of a ledger accounts could be inferred from its relations,
// but to simplify logic an enum is used. In addition this also
// makes the ledger account type known even after the relation is lost.
// Say for example if a user is deleted.
enum LedgerAccountType {
  // User ledger accounts may be attached to users and
  // may pay for items and event registrations.
  USER
  // Group ledger accounts may be attached to groups and
  // can receive money from shops and events registrations.
  GROUP
}

// A ledger account is equivalent to you real life bank account
// It is used to store internal funds for either users or groups
model LedgerAccount {
  id                  Int               @id @default(autoincrement())
  user                User?             @relation(fields: [userId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  userId              Int?              @unique
  group               Group?            @relation(fields: [groupId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  groupId             Int?              @unique
  type                LedgerAccountType
  name                String? // Optional display name for the account, only used for group accounts
  payoutAccountNumber String? // For display only, only used for group accounts

  ledgerEntries LedgerEntry[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Book keeping for why a transaction was created
// Only used for informing the user, no effect on actual logic in the ledger itself.
enum LedgerTransactionPurpose {
  SHOP_PURCHASE
  EVENT_PAYMENT
  DEPOSIT
  PAYOUT
  REFUND
}

// All ledger transactions start as pending and become
// either failed, succeeded or canceled. No other
// transitions are possible. 
enum LedgerTransactionState {
  PENDING
  FAILED
  SUCCEEDED
  CANCELED
}

// The system uses a double-entry accounting. In engineering terms this means that
// ledger transactions obey Kirchhoff's first law. That is: 
// sum of ledger entries + sum of payouts = sum of all payments
// Either all or none ledger entries and payouts in a transaction are valid.
// Payments track their own state as they depend on the external payment provider.
model LedgerTransaction {
  id      Int                      @id @default(autoincrement())
  purpose LedgerTransactionPurpose
  state   LedgerTransactionState
  reason  String? // If the transaction failed, this is the reason why.

  ledgerEntries LedgerEntry[]
  payment       Payment?      @relation(fields: [paymentId], references: [id])
  paymentId     Int?          @unique

  // Relevant relations to other tables based un purpose
  // purchase Purchase
  // deposit Deposit
  // payout Payout
  // refund 

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model LedgerEntry {
  id                  Int               @id @default(autoincrement())
  // The funds this ledger entry moves
  // Credit when > 0, debit when < 0
  funds               Int
  // Fees are the fees incurred during payment. This does not effect users balance and are only used for book keeping.
  // Optional since fees might not be known until payment is confirmed
  // Must be non-null when completing a transaction. It must be explicitly set to 0 to indicate no fees.
  fees                Int?
  // The account which should be credited/debited on completions
  ledgerAccount       LedgerAccount?    @relation(fields: [ledgerAccountId], references: [id])
  ledgerAccountId     Int
  // The transaction this ledger entry is part of
  // Accounts are credited only when the transaction succeeds.
  // Accounts are debited immediately when the transaction is created,
  // but this is reversed in case the transaction fails (essentially the funds are reserved)
  ledgerTransaction   LedgerTransaction @relation(fields: [ledgerTransactionId], references: [id])
  ledgerTransactionId Int // The entry is only valid once the transaction is valid

  // TODO: Should we have updated and created at per ledger entry?
  // TODO: Add indexes for fields which are used for look up often to increase performance
  // @@index([ledgerAccountId])
  // @@index([ledgerTransactionId])
  // @@index([paymentId])

  // Only one ledger entry for a given account may be present in a transaction
  // This is for simplicity as they could always be merged
  @@unique([ledgerTransactionId, ledgerAccountId])
}

enum PaymentProvider {
  STRIPE
  MANUAL
}

enum PaymentState {
  // Payment created, but not external API call made
  PENDING
  // Awaiting response from payment provider (webhook)
  PROCESSING
  // Failed webhook received :(
  FAILED
  // Succeed webhook received with correct funds
  SUCCEEDED
  // Cancel webhook confirmation received - NOT that we initiated a cancel 
  // set the transaction state to canceled for that
  CANCELED
}

// Payments represent external movement of funds and may be both incoming and outgoing. 
// Incoming payments are for example when users deposit money into their account.
// Outgoing payments are for example when we payout money to committees.
model Payment {
  id               Int             @id @default(autoincrement())
  // The funds that was requested for this payment
  // Use to confirm that the correct funds was captured
  // Note: positive = going into the ledger, negative = going out of the ledger
  funds            Int
  // The fees this payment incurred
  fees             Int?
  // The reason for the payment, displayed on the stripe dashboard
  descriptionLong  String?
  // The text displayed on the bank statement
  descriptionShort String?
  // The life cycle state of this payment
  state            PaymentState
  // The responsible provider for this payment
  provider         PaymentProvider
  // Only one of the following relations may be set
  // depending on the payment provider used
  stripePayment    StripePayment?
  manualPayment    ManualPayment?

  // Which ledger transaction this payment is part
  ledgerTransaction LedgerTransaction?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model StripePayment {
  payment   Payment @relation(fields: [paymentId], references: [id])
  paymentId Int     @id

  paymentIntentId String? @unique
  // The key the fronted uses to confirm the payment intent
  clientSecret    String? @unique

  // Which ledger entries have used this payment
  // Useful in case payment goes through,
  // then user can be credited unused funds
  // into their account.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Bookkeeping for when funds are transferred to or from the ledger manually by administrators.
// Important: The actual funds transferred is `funds` minus `fees`!
// Example: Say PhaestCom has earned 50'000.00 funds and 1000.00 fees.  
// Then, the actual bank transfer should equate to 49'000.00.
model ManualPayment {
  payment   Payment @relation(fields: [paymentId], references: [id])
  paymentId Int     @id

  // The bank account number where the money was sent to/from. 
  // This is only for our own bookkeeping. When sending funds out
  // of the system it has to be transferred manually by an admin!
  bankAccountNumber String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
