// In theory the type of a ledger accounts could be inferred from its relations,
// but to simplify logic an enum is used. In addition this also
// makes the ledger account type known even after the relation is lost.
// Say for example if a user is deleted.
enum LedgerAccountType {
  // User ledger accounts may be attached to users and
  // may pay for items and event registrations.
  USER
  // Group ledger accounts may be attached to groups and
  // can receive money from shops and events registrations.
  GROUP
}

// A ledger account is equivalent to you real life bank account
// It is used to store internal funds for either users or groups
model LedgerAccount {
  id                  Int               @id @default(autoincrement())
  user                User?             @relation(fields: [userId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  userId              Int?              @unique
  group               Group?            @relation(fields: [groupId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  groupId             Int?              @unique
  type                LedgerAccountType
  payoutAccountNumber String? // For display only, only used for group accounts

  ledgerEntries LedgerEntry[]
  payments      Payment[]

  // products            Product[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Book keeping for why a transaction was created
// Only used for informing the user, no effect on actual logic in the ledger itself.
enum LedgerTransactionPurpose {
  SHOP_PURCHASE
  EVENT_PAYMENT
  DEPOSIT
  PAYOUT
  REFUND
}

// All ledger transactions start as pending and become
// either failed, succeeded or canceled. No other
// transitions are possible. 
enum LedgerTransactionStatus {
  PENDING
  FAILED
  SUCCEEDED
  CANCELED
}

// The system uses a double-entry accounting. In engineering terms this means that
// ledger transactions obey Kirchhoff's first law. That is: 
// sum of ledger entries + sum of payouts = sum of all payments
// Either all or none ledger entries and payouts in a transaction are valid.
// Payments track their own state as they depend on the external payment provider.
model LedgerTransaction {
  id      Int                      @id @default(autoincrement())
  purpose LedgerTransactionPurpose
  status  LedgerTransactionStatus
  reason  String? // If the transaction failed, this is the reason why.

  ledgerEntries    LedgerEntry[]
  payment          Payment?        @relation(fields: [paymentId], references: [id])
  paymentId        Int?            @unique
  manualTransfer   ManualTransfer? @relation(fields: [manualTransferId], references: [id])
  manualTransferId Int?            @unique

  // Relevant relations to other tables based un purpose
  // purchase Purchase
  // deposit Deposit
  // payout Payout
  // refund 

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model LedgerEntry {
  id                  Int               @id @default(autoincrement())
  // The amount this ledger entry moves
  // Credit when > 0, debit when < 0
  amount              Int
  // Fees are the fees incurred during payment. This does not effect users balance and are only used for book keeping.
  // Optional since fees might not be known until payment is confirmed
  // Must be non-null when completing a transaction. It must be explicitly set to 0 to indicate no fees.
  fees                Int?
  // What type of movement this ledger entry does.
  // Determines how it is validated.
  // type                LedgerEntryType
  // The account which should be credited/debited on completions
  ledgerAccount       LedgerAccount?    @relation(fields: [ledgerAccountId], references: [id])
  ledgerAccountId     Int
  // The transaction this ledger entry is part of
  // Accounts are credited only when the transaction succeeds.
  // Accounts are debited immediately when the transaction is created,
  // but this is reversed in case the transaction fails (essentially the funds are reserved)
  ledgerTransaction   LedgerTransaction @relation(fields: [ledgerTransactionId], references: [id])
  ledgerTransactionId Int // The entry is only valid once the transaction is valid

  // TODO: Should we have updated and created at per ledger entry?
  // TODO: Add indexes for fields which are used for look up often to increase performance
  // @@index([ledgerAccountId])
  // @@index([ledgerTransactionId])
  // @@index([paymentId])

  // Only one ledger entry for a given account may be present in a transaction
  // This is for simplicity as they could always be merged
  @@unique([ledgerTransactionId, ledgerAccountId])
}

enum PaymentProvider {
  MANUAL // Admin injected money into the ledger
  STRIPE
  // TODO: VIPPS
}

enum PaymentStatus {
  // Payment created, but not external API call made
  PENDING
  // Awaiting response from payment provider (webhook)
  PROCESSING
  // Failed webhook received :(
  FAILED
  // Succeed webhook received with correct amount
  SUCCEEDED
  // Cancel webhook confirmation received - NOT that we initiated a cancel 
  // set the transaction status to canceled for that
  CANCELED
}

model Payment {
  id                Int                @id @default(autoincrement())
  // The amount that was requested for this payment
  // Use to confirm that the correct amount was captured
  amount            Int
  // The amount of fees this payment incurred
  fees              Int?
  // Lifecycle of the payment
  status            PaymentStatus
  // Which service we should call and listen to
  provider          PaymentProvider
  // If the payment provider is Stripe, then the stripe
  // payment model holds the details for the payment intent
  paymentIntentId   String?            @unique
  // The key the fronted uses to confirm the payment intent
  clientSecret      String?            @unique
  // The reason for the payment, displayed on the stripe dashboard
  description       String
  // The text displayed on the bank statement
  descriptor        String
  // The ledger account responsible for creating the payment
  // May be null if user without account is paying
  ledgerAccount     LedgerAccount?     @relation(fields: [ledgerAccountId], references: [id])
  ledgerAccountId   Int?
  // Which ledger entries have used this payment
  // Useful in case payment goes through,
  // then user can be credited unused amount
  // into their account.
  ledgerTransaction LedgerTransaction?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/**
 * // Function which users call to add money to their ledger account.
 * // Payment is completed on the client side.
 * // Required references/keys are returned with the transaction object
 * async function createDeposit(ledgerAccountId: number, amount: number, paymentProvider: string) {
 * const payment = await createPayment({ amount, paymentProvider, ... })
 * const transaction = await createTransaction({
 * entries: [{
 * ledgerAccountId,
 * amount,
 * }],
 * paymentId: payment.id,
 * })
 * return transaction
 * }
 * // Functions users call to remove money from their account and
 * // send it to their real life bank account.
 * async function createPayout(ledgerAccountId: number, amount: number, bankAccountNumber: string) {
 * const manualTransfer = createmanualTransfer({
 * data: {
 * amount,
 * fees,
 * bankAccountNumber,
 * }
 * })
 * const transaction = await createLedgerTransaction({
 * ledgerEntries: [{
 * ledgerAccountId,
 * amount: -amount,
 * }],
 * manualTransferId: manualTransfer.id,
 * })
 * return transaction
 * }
 */

// Bookkeeping for when funds are transferred to or from the ledger manually by administrators.
model ManualTransfer {
  id                Int     @id @default(autoincrement())
  // Important: The actual amount transferred is amount minus fees!
  // Example: Say PhaestCom has earned 50'000.00 Kluengende Muent in
  // revenue and 1000.00 Kluengende Muent in fees.  Then, the actual
  // bank transfer should equate to 49'000.00.
  // Note: positive = going into the ledger, negative = going out of the ledger
  amount            Int
  fees              Int
  // The bank account number where the money was sent to/from. 
  // This is only for our own bookkeeping. When sending funds
  // out of the system it has to be transferred manually by HS!
  bankAccountNumber String?
  comment           String?

  ledgerTransaction LedgerTransaction?
}

// // The type of a ledger entry determines how it is validated.
// // NOTE: In the context of ledger "credit" means to receive money and "debit" means to loose money
// enum LedgerEntryType {
//   // The entry must reference a account
//   // No other special requirements
//   INTERNAL_CREDIT
//   // The entry must reference a account and that account
//   // must have a non-negative balance after the transaction.
//   INTERNAL_DEBIT
//   // Represents money coming into the system.
//   // The entry must reference a succeed payment with
//   // enough value to cover the amount.
//   EXTERNAL_DEBIT
//   // Represents money going out of the system.
//   // No special requirements.
//   EXTERNAL_CREDIT
// }
