// In theory the type of a ledger accounts could be inferred from its relations,
// but to simplify logic an enum is used. In addition this also
// makes the ledger account type known even after the relation is lost.
// Say for example if a user is deleted.
enum LedgerAccountType {
  // User ledger accounts may be attached to users and
  // may pay for items and event registrations.
  USER
  // Group ledger accounts may be attached to groups and
  // can receive money from shops and events registrations.
  GROUP
}

// A ledger account is equivalent to you real life bank account
// It is used to store internal funds for either users or groups
model LedgerAccount {
  id                  Int               @id @default(autoincrement())
  user                User?             @relation(fields: [userId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  userId              Int?              @unique
  group               Group?            @relation(fields: [groupId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  groupId             Int?              @unique
  type                LedgerAccountType
  payoutAccountNumber String? // For display only, only used for group accounts

  ledgerEntries LedgerEntry[]
  payments      Payment[]

  // products            Product[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Book keeping for why a transaction was created
// Only used for informing the user, no effect on actual logic in the ledger itself.
enum LedgerTransactionPurpose {
  SHOP_PURCHASE
  EVENT_PAYMENT
  DEPOSIT
  PAYOUT
  REFUND
}

// All ledger transactions start as pending and become
// either failed, succeeded or canceled. No other
// transitions are possible. 
enum LedgerTransactionStatus {
  PENDING
  FAILED
  SUCCEEDED
  CANCELED
}

// The system uses a double-entry accounting. In engineering terms this means that
// ledger transactions obey Kirchhoff's first law. That is: 
// sum of ledger entries + sum of payouts = sum of all payments
// Either all or none ledger entries and payouts in a transaction are valid.
// Payments track their own state as they depend on the external payment provider.
model LedgerTransaction {
  id            Int                      @id @default(autoincrement())
  purpose       LedgerTransactionPurpose
  status        LedgerTransactionStatus
  ledgerEntries LedgerEntry[]
  payment       Payment? @relation(fields: [paymentId], references: [id])
  paymentId     Int? @unique
  payout        Payout? @relation(fields: [payoutId], references: [id])
  payoutId      Int? @unique

  // Relevant relations to other tables based un purpose
  // purchase Purchase
  // deposit Deposit
  // payout Payout
  // refund 

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model LedgerEntry {
  id                  Int               @id @default(autoincrement())
  // The amount this ledger entry moves
  // Credit when > 0, debit when < 0
  amount              Int
  // Fees are the fees incurred during payment. This does not effect users balance and are only used for book keeping.
  // Optional since fees might not be known until payment is confirmed
  // Must be non-null when completing a transaction. It must be explicitly set to 0 to indicate no fees.
  fees                Int?
  // What type of movement this ledger entry does.
  // Determines how it is validated.
  // type                LedgerEntryType
  // The account which should be credited/debited on completions
  ledgerAccount       LedgerAccount?    @relation(fields: [ledgerAccountId], references: [id])
  ledgerAccountId     Int
  // The transaction this ledger entry is part of
  // Accounts are credited only when the transaction succeeds.
  // Accounts are debited immediately when the transaction is created,
  // but this is reversed in case the transaction fails (essentially the funds are reserved)
  ledgerTransaction   LedgerTransaction @relation(fields: [ledgerTransactionId], references: [id])
  ledgerTransactionId Int // The entry is only valid once the transaction is valid

  // TODO: Should we have updated and created at per ledger entry?
  // TODO: Add indexes for fields which are used for look up often to increase performance
  // @@index([ledgerAccountId])
  // @@index([ledgerTransactionId])
  // @@index([paymentId])

  // Only one ledger entry for a given account may be present in a transaction
  // This is for simplicity as they could always be merged
  @@unique([ledgerTransactionId, ledgerAccountId])
}

enum PaymentProvider {
  MANUAL // Admin injected money into the ledger
  STRIPE
  // TODO: VIPPS
}

enum PaymentStatus {
  // Payment created, but not external API call made
  PENDING
  // Awaiting response from payment provider (webhook)
  PROCESSING
  // Failed webhook received :(
  FAILED
  // Succeed webhook received with correct amount
  SUCCEEDED
  // Cancel webhook confirmation received - NOT that we initiated a cancel 
  // set the transaction status to canceled for that
  CANCELED
}

model Payment {
  id                  Int               @id @default(autoincrement())
  // The amount that was requested for this payment
  // Use to confirm that the correct amount was captured
  amount              Int
  // The amount of fees this payment incurred
  fees                Int?
  // Lifecycle of the payment
  status              PaymentStatus
  // Which service we should call and listen to
  provider            PaymentProvider
  // If the payment provider is Stripe, then the stripe
  // payment model holds the details for the payment intent
  paymentIntentId     String?           @unique
  // The key the fronted uses to confirm the payment intent
  clientSecret        String?           @unique
  // The reason for the payment, displayed on the stripe dashboard
  description         String
  // The text displayed on the bank statement
  descriptor          String
  // The ledger account responsible for creating the payment
  // May be null if user without account is paying
  ledgerAccount       LedgerAccount?    @relation(fields: [ledgerAccountId], references: [id])
  ledgerAccountId     Int?
  // Which ledger entries have used this payment
  // Useful in case payment goes through,
  // then user can be credited unused amount
  // into their account.
  ledgerTransaction   LedgerTransaction?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Bookkeeping for where money has been sent out from the website
model Payout {
  id                Int     @id @default(autoincrement())
  amount            Int
  fees              Int?
  // The bank account number is only for our own bookkeeping.
  // The money has to be transferred manually by HS!
  bankAccountNumber String?
  comment           String?

  ledgerTransaction   LedgerTransaction?
}

// // The type of a ledger entry determines how it is validated.
// // NOTE: In the context of ledger "credit" means to receive money and "debit" means to loose money
// enum LedgerEntryType {
//   // The entry must reference a account
//   // No other special requirements
//   INTERNAL_CREDIT
//   // The entry must reference a account and that account
//   // must have a non-negative balance after the transaction.
//   INTERNAL_DEBIT
//   // Represents money coming into the system.
//   // The entry must reference a succeed payment with
//   // enough value to cover the amount.
//   EXTERNAL_DEBIT
//   // Represents money going out of the system.
//   // No special requirements.
//   EXTERNAL_CREDIT
// }
